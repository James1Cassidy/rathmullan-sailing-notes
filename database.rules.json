    {
    "rules": {
        ".read": false,
        ".write": false,

        "users": {
        ".read": "auth != null",
        "$uid": {
            ".write": "auth != null && (auth.uid === $uid || auth.token.admin === true)",
            "notificationPrefs": {
            ".read": "$uid === auth.uid",
            ".write": "$uid === auth.uid"
            },
            "approved": {
            ".write": "auth.token.admin === true"
            },
            "role": {
            ".write": "auth.token.admin === true"
            }
        }
        },

        "announcements": {
        ".read": "auth != null && root.child('users').child(auth.uid).exists()",
        ".write": "auth != null && root.child('users').child(auth.uid).child('approved').val() === true",
        "$announcementId": {
            ".validate": "newData.hasChildren(['text', 'author', 'timestamp'])"
        }
        },

        "chat": {
        "messages": {
            ".read": "auth != null && root.child('users').child(auth.uid).child('approved').val() === true",
            ".write": "auth != null && root.child('users').child(auth.uid).child('approved').val() === true",
            "$messageId": {
            ".validate": "newData.hasChildren(['userId', 'name', 'ts'])"
            }
        }
        },

        "privateMessages": {
        ".read": "auth != null && root.child('users').child(auth.uid).child('approved').val() === true",
        "$messageId": {
            // Allow read if requester is sender or recipient. Support legacy field names 'from'/'to' as well.
            ".read": "auth != null && (data.child('senderId').val() === auth.uid || data.child('recipientId').val() === auth.uid || data.child('from').val() === auth.uid || data.child('to').val() === auth.uid)",
            // Allow create/update only when the new data's sender matches the caller (support senderId or legacy 'from').
            // Allow delete when the existing data's sender matches the caller (newData does not exist on delete).
            ".write": "auth != null && ( (newData.exists() && (newData.child('senderId').val() === auth.uid || newData.child('from').val() === auth.uid)) || (!newData.exists() && (data.child('senderId').val() === auth.uid || data.child('from').val() === auth.uid)) )"
        }
        },

        "students": {
        ".read": "auth != null && root.child('users').child(auth.uid).exists()",
        ".write": "auth != null && root.child('users').child(auth.uid).child('approved').val() === true"
        },

        "studentNotes": {
        ".read": "auth != null && root.child('users').child(auth.uid).exists()",
        ".write": "auth != null && root.child('users').child(auth.uid).child('approved').val() === true"
        },

        "weeklyPlan": {
        ".read": "auth != null && root.child('users').child(auth.uid).exists()",
        ".write": "auth != null && root.child('users').child(auth.uid).child('approved').val() === true"
        },

        "weeklyTemplates": {
        ".read": "auth != null && root.child('users').child(auth.uid).exists()",
        ".write": "auth != null && root.child('users').child(auth.uid).child('approved').val() === true"
        },

        "arrangement": {
        ".read": "auth != null && root.child('users').child(auth.uid).exists()",
        ".write": "auth != null && root.child('users').child(auth.uid).child('approved').val() === true"
        },

        "mapPositions": {
        ".read": "auth != null && root.child('users').child(auth.uid).exists()",
        ".write": "auth != null && root.child('users').child(auth.uid).child('approved').val() === true"
        },

        "availability": {
        ".read": "auth != null && root.child('users').child(auth.uid).exists()",
        "$instructorId": {
            ".write": "auth != null && ($instructorId === auth.uid || root.child('users').child(auth.uid).child('approved').val() === true)"
        }
        },

        "repairsLog": {
        ".read": "auth != null && root.child('users').child(auth.uid).exists()",
        ".write": "auth != null && root.child('users').child(auth.uid).child('approved').val() === true",
        ".indexOn": ["timestamp"]
        },



        "system": {}
    }
    }
